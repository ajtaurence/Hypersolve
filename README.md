# About
Hypersolve is a work-in-progress efficient 3-phase 2<sup>4</sup> Rubik's cube solver written in rust. Currently it is being developed as a command line application but may also have a gui built for it. Hypersolve can generate true random state scrambles, not relying on sufficiently long random sequences of moves. These random state scrambles come with a verification key that can be used to prove that the scramble came from Hypersolve and is untampered, making scramble cheating impossible. Hypersolve is capable of solving random state scrambles in only 21-24 moves STM within less than a second! For a full list of features see [commands](#commands).


# Commands

## Solve
Finds solutions to a scramble

### Args
* scramble: Space-separated list of twists in MC4D format specifying the scramble
* mode (default: fast)
    * fast: Finds relatively short solutions very quickly by searching for solutions shorter than the last one found
    * optimal (not yet implemented): Finds the optimal solution to the scramble

## Bound (not yet implemented)
Finds upper and lower bounds on the length of the optimal solution to the scramble

### Args
* scramble: Space-separated list of twists in MC4D format specifying the scramble


## Scramble
Generates a true random state scramble with a 128 bit hexadecimal verification key for [verifying](#verify) that the scramble was randomly generated and untampered

### Args
* verification key (default: random): Verification key to use for scramble generation

## Verify
Verifies that a scramble is a true random state scramble generated by Hypersolve using the verification key

### Args
* verification key: Verification key for the scramble
* scramble: Space-separated list of twists in MC4D format specifying the scramble

## Simplify (not yet implemented)
Simplifes a twist sequence

### Args
* sequence: Space-separated list of twists in MC4D format specifying the twist sequence
* mode (default: fast)
    * trivial: Applies trivial simplifications to the sequence such as combining moves where possible and re-writing without cube rotations
    * non-trivia: Searches for shorter but equivalent sequences


# Hardware Details

## CPU
Most operations that Hypersolve performs are non-parallelizable by nature and will not benefit from multiple cores. However, fast solve mode is multithreaded and may significantly benefit from CPUs capable of running up to 12 threads concurrently. The initial data generation will also take advantage of all available cores.

## Ram
Hypersolve will use a maximum of about 1.5 GB of ram. Most of this is pre-generated lookup tables.

## Disk Space
Hypersolve requires about 1.5 GB of disk space to store several pre-computed lookup tables.


# Verification Details
Hypersolve verification works by producing (or receiving) a random 128 bit key when a scramble is requested. The key is then hashed using the [SHA256](https://en.wikipedia.org/wiki/SHA-2) hashing algorithm. The first 128 bits are kept and the rest are discarded. The hashed key is converted into an index ranging from 0 to 3,357,894,533,384,932,272,635,904,000 which uniquely identifies a 2<sup>4</sup> state. Now that a 2<sup>4</sup> state has been selected, Hypersolve quickly finds a sequence which solves that state. It then inverts that solution to obtain the scramble which results in that state.

During the verification process, the verification key is provided along with the scramble. Hypersolve simply re-generates the scramble from the key and ensures that the generated scramble matches the provided scramble.

This process ensures that it is essentially impossible to force Hypersolve to output a scramble for a particular desired state since this would require reversing the hash function. Additionally, one cannot pass off the scramble as their solution and their solution as the scramble by inverting them since the scramble must not just result in the correct state, but have the exact expected form.
