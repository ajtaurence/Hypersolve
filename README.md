# Hypersolve

Hypersolve is an efficient 3-phase [2<sup>4</sup> Rubik's cube](https://hypercubing.xyz/puzzles/2x2x2x2/) solver written in Rust. It is currently developed as a command-line application, with potential for a future GUI.

## Features

*   **Fast Solving**: Solves random state scrambles in approximately 21-24 moves STM within a few seconds.
*   **True Random State Scrambles**: Generates genuinely random state scrambles, eliminating reliance on sufficiently long random move sequences.
*   **Scramble Verification**: Generated scrambles come with a 128-bit hexadecimal verification key, ensuring their authenticity and preventing tampering.

For a full list of features and commands, see the [Commands](#commands) section. For build instructions, see [Building](#building).

## Project Structure

The Hypersolve project is organized into two main crates:

*   `hypersolve/`: The main command-line application. It provides the user interface and orchestrates the solving and scramble generation processes.
*   `hypersolve-lib/`: A library containing the core logic for 2<sup>4</sup> cube manipulation, solving algorithms, and scramble generation. This separation allows for potential reuse in other applications or a GUI.

## Hardware Details

*   **RAM**: Hypersolve typically uses about 1.5 GB of RAM during operation.
*   **Disk Space**: Approximately 1.5 GB of disk space is required to store several lookup tables, which are computed on their first use.

## Verification Details

Hypersolve's verification process ensures the integrity of generated scrambles:

1.  **Key Generation**: A random 128-bit key is produced (or provided) when a scramble is requested.
2.  **Hashing**: This key is hashed using the [SHA256](https://en.wikipedia.org/wiki/SHA-2) algorithm. The first 128 bits of the hash are retained.
3.  **Index Mapping**: The hashed key is converted into a unique index ranging from 0 to 3,357,894,533,384,932,272,635,904,000, which uniquely identifies a 2<sup>4</sup> state.
4.  **Solution Inversion**: Hypersolve quickly finds a sequence of moves that solves this identified state, then inverts that solution to obtain the scramble that leads to the state.

During verification, the provided verification key and scramble are used to regenerate the expected scramble. If the regenerated scramble matches the provided one, the scramble is deemed valid. This process makes it virtually impossible to force Hypersolve to output a scramble for a specific desired state (due to the one-way nature of the hash function) and prevents users from passing off solutions as scrambles by inversion, as the scramble must match the exact expected form.

## Commands

Hypersolve provides the following commands:

### `fast-solve <moves> [--output <notation>]`

Finds relatively short solutions very quickly by iteratively searching for solutions shorter than the last one, eventually terminating with an optimal solution.

*   `<moves>`: The scramble moves (e.g., `FI IUL RBO UI IF FU RI`).
*   `--output <notation>`: (Optional) The notation in which to output the solution. Can be `Standard` (default) or `mc4d`.

**Example:**
```sh
hypersolve fast-solve FI IUL RBO UI IF FU RI
```

### `optimal-solve <moves> [--min <length>] [--max <length>] [--number <count>] [--per-length <count>] [--output <notation>]`

Finds the shortest possible solutions in order of increasing length.

*   `<moves>`: The scramble moves.
*   `--min <length>`: (Optional) Minimum solution length (default: 0).
*   `--max <length>`: (Optional) Limit the maximum length of solutions to search for.
*   `--number <count>`: (Optional) Limit the total number of solutions to output.
*   `--per-length <count>`: (Optional) Limit the number of solutions output per solution length.
*   `--output <notation>`: (Optional) The notation in which to output the solution. Can be `Standard` (default) or `mc4d`.

**Example:**
```sh
hypersolve optimal-solve FI IUL RBO UI IF FU RI --max 20 --number 5
```

### `bound <moves>`

Computes bounds on the length of the optimal solution to a scramble.

*   `<moves>`: The scramble moves.

**Example:**
```sh
hypersolve bound FI IUL RBO UI IF FU RI
```

### `scramble [--key <hex_key>] [--output <notation>]`

Generates a true random state scramble with a 128-bit hexadecimal verification key.

*   `--key <hex_key>`: (Optional) Use a custom 128-bit hexadecimal verification key (32 hexadecimal characters) instead of generating a random one.
*   `--output <notation>`: (Optional) The notation in which to output the scramble. Can be `Standard` (default) or `mc4d`.

**Example:**
```sh
hypersolve scramble
hypersolve scramble --key a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6 --output mc4d
```

### `verify-scramble <key> <scramble_moves>`

Verifies that a scramble is a true random state scramble generated by Hypersolve using the provided verification key.

*   `<key>`: The 128-bit hexadecimal verification key.
*   `<scramble_moves>`: The scramble moves to verify.

**Example:**
```sh
hypersolve verify-scramble "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6" FI IUL RBO UI IF FU RI
```

### `invert <moves> [--output <notation>]`

Computes the inverse of a move sequence.

*   `<moves>`: The moves to invert.
*   `--output <notation>`: (Optional) The notation in which to output the result. Can be `Standard` (default) or `mc4d`.

**Example:**
```sh
hypersolve invert FI IUL RBO UI IF FU RI
```

### `convert <moves> <notation>`

Converts a sequence of moves to the specified notation.

*   `<moves>`: The moves to convert.
*   `<notation>`: The target notation. Can be `Standard` or `mc4d`.

**Example:**
```sh
hypersolve convert FI IUL RBO UI IF FU RI mc4d
```

## Building

1.  **Install Rust / Cargo**: If you don't have Rust and Cargo installed, follow the instructions on the [official Rust website](https://www.rust-lang.org/tools/install).
2.  **Clone the repository and build**:

    ```sh
    git clone https://github.com/ajtaurence/Hypersolve.git
    cd Hypersolve/hypersolve
    cargo build --release
    ```

    The compiled executable will be located in `hypersolve/target/release`.


