use depth_queue::DepthQueue;
use rkyv::{Archive, Deserialize, Serialize};
use std::{
    hash::Hash,
    marker::PhantomData,
    ops::{Deref, DerefMut},
};

use nohash_hasher::IntMap as HashMap;

use hypersolve_core::*;

use crate::*;

/// A trait for objects that can act as pruning tables, storing the lower bound
/// on the distance from solved for any node
pub trait PruningTable<N: Node> {
    /// Creates an empty pruning table for the given phase
    fn new(max_depth: u8) -> Self;

    /// Set the depth of the node
    fn set_depth(&mut self, node: &N, depth: u8);

    /// Gets a lower bound on the depth of the node
    fn get_depth_bound(&self, node: &N) -> u8;

    /// Updates the max depth if all states were found before the maximum depth
    fn update_max_depth(&mut self, new_max_depth: u8);

    /// Anything that needs to be done to the pruning table after it is done being generated
    fn finalize(&mut self);

    /// Generates the pruning table to the desired depth
    fn generate(depth: u8) -> Self
    where
        Self: Sized,
    {
        // Create the pruning table
        let mut pruning_table = Self::new(depth);

        // Create the queue
        let mut queue = DepthQueue::<(N, Option<Axis>)>::new();

        // Set the goal node and push it to the queue
        pruning_table.set_depth(&N::GOAL, 0);
        queue.push((N::GOAL, None));

        loop {
            if let Some((node, last_axis)) = queue.pop() {
                for (new_node, new_last_axis) in Move::<N::Phase>::iter()
                    .filter(|m| !last_axis.is_some_and(|a| m.axis() == a))
                    .map(|m| (node.apply_move(m), Some(m.axis())))
                {
                    if pruning_table.get_depth_bound(&new_node) > queue.depth() {
                        pruning_table.set_depth(&new_node, queue.depth());
                        if queue.depth < depth {
                            queue.push((new_node, new_last_axis));
                        }
                    }
                }
            } else {
                pruning_table.update_max_depth(queue.depth());
                break;
            }
        }

        pruning_table.finalize();

        pruning_table
    }
}

/// Like a regular pruning table but is read only and generated by rkyv for zero copy deserialization
pub trait ArchivedPruningTable<N: Node> {
    /// Gets a lower bound on the depth of the node
    fn get_depth_bound(&self, node: N) -> u8;
}

/// A pruning table backed by a hashmap for storing a selection of nodes in phases where the
/// set of all nodes is too large to store them all.
#[derive(Archive, Serialize, Deserialize)]
pub struct HashMapPruningTable<N: Node> {
    pub data: HashMap<N::Index, u8>,
    pub max_depth: u8,
}

impl<N: Node> PruningTable<N> for HashMapPruningTable<N> {
    fn new(max_depth: u8) -> Self {
        HashMapPruningTable {
            data: HashMap::default(),
            max_depth,
        }
    }

    fn get_depth_bound(&self, node: &N) -> u8 {
        match self.data.get(&{ node.index() }) {
            Some(&depth) => depth,
            None => self.max_depth + 1,
        }
    }

    fn set_depth(&mut self, node: &N, depth: u8) {
        self.data.insert(node.index(), depth);
    }

    fn update_max_depth(&mut self, new_max_depth: u8) {
        self.max_depth = new_max_depth;
    }

    fn finalize(&mut self) {
        self.data.shrink_to_fit()
    }
}

impl<N: Node> ArchivedPruningTable<N> for ArchivedHashMapPruningTable<N>
where
    <N::Index as Archive>::Archived: Hash + std::cmp::Eq,
{
    fn get_depth_bound(&self, node: N) -> u8 {
        match self.data.get(&node.index()) {
            Some(&depth) => depth,
            None => self.max_depth + 1,
        }
    }
}

/// A pruning table backed by an array where each state has a unique index to store its distance
#[derive(Debug, Archive, Serialize, Deserialize)]
pub struct ArrayPruningTable<N: Node> {
    data: Box<[u8]>,
    max_depth: u8,
    phantom: PhantomData<N>,
}

impl<N: Node> Deref for ArrayPruningTable<N> {
    type Target = [u8];
    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

impl<N: Node> DerefMut for ArrayPruningTable<N> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.data
    }
}

impl<N: Node> PruningTable<N> for ArrayPruningTable<N> {
    fn new(max_depth: u8) -> Self {
        Self {
            data: vec![max_depth + 1; N::N_STATES].into_boxed_slice(),
            max_depth,
            phantom: PhantomData,
        }
    }

    fn set_depth(&mut self, node: &N, depth: u8) {
        self[node.index().into() as usize] = depth;
    }

    fn get_depth_bound(&self, node: &N) -> u8 {
        self[node.index().into() as usize]
    }

    fn update_max_depth(&mut self, new_max_depth: u8) {
        self.max_depth = new_max_depth
    }

    fn finalize(&mut self) {}
}

impl<N: Node> ArchivedPruningTable<N> for ArchivedArrayPruningTable<N> {
    fn get_depth_bound(&self, node: N) -> u8 {
        unsafe { assert_unchecked!(node.index().into() < self.data.len() as u64) };

        self.data[node.index().into() as usize]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_phase1_pruning_table() {
        let pruning_table = HashMapPruningTable::<Phase1Node>::generate(2);
        // Should have found 166 nodes
        assert_eq!(pruning_table.data.len(), 166);
    }

    #[test]
    fn test_phase2_pruning_table() {
        let pruning_table = HashMapPruningTable::<Phase2Node>::generate(2);
        // Should have found 152 nodes
        assert_eq!(pruning_table.data.len(), 152);
    }

    #[test]
    fn test_phase3_pruning_table() {
        let pruning_table = HashMapPruningTable::<Phase3Node>::generate(2);
        // Should have found 70 nodes
        assert_eq!(pruning_table.data.len(), 70);
    }
}
