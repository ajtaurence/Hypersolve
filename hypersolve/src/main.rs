use clap::{Parser, Subcommand, ValueEnum};
use colored::Colorize;
use hypersolve::*;


#[derive(Parser)]
#[command(
    author, 
    version,
    about,
    long_about = None,
    help_template = "{about-section}Author: {author}\n\n{usage-heading} {usage} \n\n{all-args} {tab}"
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Solves a scramble
    Solve {
        /// Scramble moves (space separated MC4D format)
        moves: Vec<Twist>,

        /// The notation in which to output the solution
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        notation: NotationEnum,
    },
    /// Generates a true random state scramble
    Scramble {
        /// Set the 128 bit hexadecimal verification key (32 hexadecimal characters) instead of generating a random key
        #[arg(short, long)]
        key: Option<HexString<16>>,

        /// The notation in which to output the scramble
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        notation: NotationEnum,
    },
    /// Verifies that a scramble was randomly generated by Hypersolve
    Verify {
        /// 128 bit hexadecimal verification key (32 hexadecimal characters)
        key: HexString<16>,

        /// Scramble moves (space separated MC4D format)
        scramble: Vec<Twist>       
    }
}

#[derive(Debug, Clone, Copy, ValueEnum)]
enum NotationEnum {
    /// Standard twist notation as described in https://hypercubing.xyz/notation
    Standard,
    /// Twist notation used in MC4D
    MC4D
}

impl From<NotationEnum> for Notation {
    fn from(value: NotationEnum) -> Self {
        match value {
            NotationEnum::Standard => Notation::Standard,
            NotationEnum::MC4D => Notation::MC4D
        }
    }
}



fn main() {
    // Setup human panic
    human_panic::setup_panic!(Metadata {
        name: capitalize_first_letter(env!("CARGO_PKG_NAME")).into(),
        version: env!("CARGO_PKG_VERSION").into(),
        authors: env!("CARGO_PKG_AUTHORS").into(),
        homepage: "https://github.com/ajtaurence/Hypersolve/issues".into(),
    });

    // make windows colorize text correctly
    #[cfg(windows)]
    colored::control::set_virtual_terminal(true).unwrap();

    let args = Cli::parse();

    match args.command {
        Commands::Solve { moves , notation} => solve(moves, notation.into()),
        Commands::Scramble { key , notation} => scramble(key, notation.into()),
        Commands::Verify { key, scramble} => verify(key, scramble),
    }
}

/// Function called on solve command
fn solve(moves: Vec<Twist>, notation: Notation) {
    let solutions = fast_solve(moves, None);
    while let Ok((solution, length)) = solutions.recv() {
        println!("[{}]", format!("{} STM", length).yellow().underline());
        println!("{}", solution.to_notation(notation));
    }
}

/// Function called on scramble command
fn scramble(key: Option<HexString<16>>, notation: Notation) {
    let key = key.unwrap_or(HexString::get_random());

    let cube_index = key.to_cube_index();

    println!("Verification key: [{}]", key.to_string().yellow().underline());
    println!("{}", find_scramble(cube_index).to_notation(notation))
}

/// Function called on verify command
fn verify(key: HexString<16>, scramble: impl IntoIterator<Item = Twist>) {
    let expected_scramble = find_scramble(key.to_cube_index());

    if expected_scramble == scramble.into_iter().collect() {
        println!("{}", "Valid".green())
    } else {
        println!("{}", "Invalid".red());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scramble() {
        for _ in 0..20 {
            scramble(Some(HexString::get_random()), Notation::Standard);
        }
    }

    #[test]
    fn test_solve() {
        solve(vec![Twist::from_mc4d_twist_string("1,1,1").unwrap()], Notation::Standard);
    }


    #[test]
    fn test_verify() {
        for _ in 0..20 {
            let key = HexString::get_random();

            let scramble = find_scramble(key.to_cube_index());
            verify(key, scramble);
        }
    }
}