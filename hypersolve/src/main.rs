use std::num::NonZeroUsize;

use clap::{Parser, Subcommand, ValueEnum};
use colored::Colorize;
use hypersolve::*;


#[derive(Parser)]
#[command(
    author, 
    version,
    about,
    long_about = None,
    help_template = "{about-section}Author: {author}\n\n{usage-heading} {usage} \n\n{all-args} {tab}"
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Finds relatively short solutions very quickly by iteratively searching for solutions shorter than the last one
    FastSolve {
        /// Scramble moves
        moves: Vec<Twist>,

        /// The notation in which to output the solution
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        output: NotationEnum,
    },
    /// Finds the shortest possible solutions in order of increasing length
    OptimalSolve {
        /// Scramble moves
        moves: Vec<Twist>,

        /// Minimum solution length
        #[arg(short, long, default_value_t = 0)]
        min: usize,

        /// Limit the length of solutions
        #[arg(short('l'), long)]
        max: Option<usize>,

        /// Limit the number of solutions
        #[arg(short, long)]
        number: Option<usize>,

        /// Limit the number of solutions given per solution length
        #[arg(short, long)]
        per_length: Option<NonZeroUsize>,

        /// The notation in which to output the solution
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        output: NotationEnum,
    },
    /// Compute bounds on the length of the optimal solution to a scramble
    Bound {
        /// Scramble moves
        moves: Vec<Twist>,
    },
    /// Generates a true random state scramble
    Scramble {
        /// Use a custom 128 bit hexadecimal verification key (32 hexadecimal characters) instead of generating a random key
        /// Use a custom 128 bit hexadecimal verification key (32 hexadecimal characters) instead of generating a random key
        #[arg(short, long)]
        key: Option<HexString<16>>,

        /// The notation in which to output the scramble
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        output: NotationEnum,
    },
    /// Verifies that a scramble was randomly generated by Hypersolve
    VerifyScramble {
        /// 128 bit hexadecimal verification key
        key: HexString<16>,

        /// Scramble moves
        /// Scramble moves
        scramble: Vec<Twist>       
    },
    /// Computes the inverse of a move sequence
    Invert {
        /// Moves to invert
        moves: Vec<Twist>,

        /// The notation in which to output the result
        #[arg(short, long, value_enum, default_value_t = NotationEnum::Standard)]
        output: NotationEnum,
    },
    /// Converts the moves to the given notation
    Convert {
        /// Moves to invert
        moves: Vec<Twist>,
        /// The notation in which to output the result
        output: NotationEnum,
    },
}

#[derive(Debug, Clone, Copy, ValueEnum)]
enum NotationEnum {
    /// Standard twist notation as described in https://hypercubing.xyz/notation
    Standard,
    /// Twist notation used in MC4D
    MC4D
}


impl From<NotationEnum> for Notation {
    fn from(value: NotationEnum) -> Self {
        match value {
            NotationEnum::Standard => Notation::Standard,
            NotationEnum::MC4D => Notation::MC4D
        }
    }
}

fn main() {
    // Setup human panic
    human_panic::setup_panic!(human_panic::Metadata::new(capitalize_first_letter(env!("CARGO_PKG_NAME")), env!("CARGO_PKG_VERSION"))
        .authors(env!("CARGO_PKG_AUTHORS"))
        .homepage("https://github.com/ajtaurence/Hypersolve/issues")
    );

    // make windows colorize text correctly
    #[cfg(windows)]
    colored::control::set_virtual_terminal(true).unwrap();

    let args = Cli::parse();

    match args.command {
        Commands::FastSolve { moves ,  output} => {
            let cube = Cube::SOLVED.twist_seq(moves);
    
            let solutions = cube.fast_solutions(None);
                
            for (solution, length) in solutions {
                println!("[{}]", format!("{} STM", length).yellow().underline());
                println!("{}", solution.to_notation(output.into()));
            }
        },
        Commands::OptimalSolve { moves , min, max, number, per_length, output} =>  {
            fn print_solutions(mut solutions: ShortestSolutionIterator, notation: NotationEnum, number: Option<usize>,  per_length: Option<NonZeroUsize>) {               
                let mut sol_len = None;
                let mut count = number.map(|n| (0_usize, n));
                let mut per_length_count = per_length.map(|p| (0_usize, p));

                while let Some(solution) = solutions.next() {
                    if count.is_some_and(|(c, l)| c >= l){
                        return;
                    }
                    if per_length_count.is_some_and(|(c, l)| c >= usize::from(l)) {
                        per_length_count = Some((0,per_length_count.unwrap().1));
                        solutions.set_to_length(sol_len.unwrap_or(0) + 1);
                        continue;
                    }

                    if sol_len != Some(solution.len()) {
                        if let Some((c, _)) = per_length_count.as_mut() {
                            *c = 0;
                        }

                        sol_len = Some(solution.len());
                        if let Some((c, _)) = per_length_count.as_mut() {
                            *c = 0;
                        }

                        println!("[{}]", format!("{} STM", solution.len()).yellow().underline());
                    }

                    println!("{}", Notation::from(notation).format_twist_sequence(&solution));
                    if let Some((c, _)) = per_length_count.as_mut() {
                        *c += 1;
                    }
                    if let Some((c, _)) = count.as_mut() {
                        *c += 1;
                    }
                }

            }            
            
            let cube = Cube::SOLVED.twist_seq(moves);
            
            match max {
                None =>  print_solutions(cube.solutions(min..), output,  number, per_length),
                Some(len) => print_solutions(cube.solutions(min..=len), output,   number, per_length),
            }
        },
        Commands::Bound { moves } => {
            let bounds = Cube::SOLVED.twist_seq(moves).optimal_bounds();

            for bound in bounds {
                if bound.upper == bound.lower {
                    println!("Optimal solution length: {}", bound.upper)
                } else {
                    println!("Lower: {} Upper: {}", bound.lower, bound.upper)
                }
            }

        },
        Commands::Scramble { key , output} => {
            let key = key.unwrap_or(HexString::get_random());

            let cube_index = key.to_cube_index();

            println!("Verification key: {}", key.to_string().yellow().underline());
            println!("{}",  new_scramble(cube_index).to_notation(output.into()) )
        },
        Commands::VerifyScramble { key, scramble} => {
            let expected_scramble = new_scramble(key.to_cube_index());

            if expected_scramble == scramble.into_iter().collect() {
                println!("{}", "Valid".green())
            } else {
                println!("{}", "Invalid".red());
            }
        },
        Commands::Invert { moves, output } => {
            let s = Notation::from(output).format_twist_sequence(&TwistSequence(moves).inverse());

            println!("{}", s)
        },
        Commands::Convert { moves, output } => {
            let s = Notation::from(output).format_twist_sequence(&TwistSequence(moves));

            println!("{}", s)
        },
    }
}