use clap::{Parser, Subcommand};
use hypersolve_lib::*;
use hypersolve::HexString;
use colored::Colorize;


#[derive(Parser)]
#[command(
    author, 
    version,
    about,
    long_about = None,
    help_template = "{about-section}Author: {author}\n\n{usage-heading} {usage} \n\n{all-args} {tab}"
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Solves a scramble
    Solve {
        /// Scramble moves (space separated MC4D format)
        moves: Vec<Twist>,
    },
    /// Generates a true random state scramble
    Scramble {
        /// Set the 128 bit hexadecimal verification key (32 hexadecimal characters) instead of generating a random key
        #[arg(short, long)]
        key: Option<HexString<16>>,
    },
    /// Verifies that a scramble was randomly generated by Hypersolve
    Verify {
        /// 128 bit hexadecimal verification key (32 hexadecimal characters)
        key: HexString<16>,

        /// Scramble moves (space separated MC4D format)
        scramble: Vec<Twist>
    }
}

fn main() {
    // make windows colorize text correctly
    #[cfg(windows)]
    colored::control::set_virtual_terminal(true).unwrap();

    let args = Cli::parse();

    match args.command {
        Commands::Solve { moves } => solve(moves),
        Commands::Scramble { key } => scramble(key),
        Commands::Verify { key, scramble } => verify(key, scramble),
    }
}

/// Function called on solve command
fn solve(moves: Vec<Twist>) {
    let solutions = fast_solve(moves, None);
    while let Ok((solution, length)) = solutions.recv() {
        println!("[{}]", format!("{} STM", length).yellow().underline());
        println!("{}", solution);
    }
}

/// Function called on scramble command
fn scramble(key: Option<HexString<16>>) {
    let key = key.unwrap_or(HexString::get_random());

    let cube_index = key.to_cube_index();

    println!("Verification key: [{}]", key.to_string().yellow().underline());
    println!("{}", generate_scramble(cube_index).unwrap())
}

/// Function called on verify command
fn verify(key: HexString<16>, scramble: impl IntoIterator<Item = Twist>) {
    let expected_scramble = generate_scramble(key.to_cube_index()).unwrap();

    if expected_scramble == scramble.into_iter().collect() {
        println!("{}", "Valid".green())
    } else {
        println!("{}", "Invalid".red());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scramble() {
        for _ in 0..20 {
            scramble(Some(HexString::get_random()));
        }
    }

    #[test]
    fn test_solve() {
        solve(vec![Twist::from_mc4d_twist_string("1,1,1").unwrap()]);
    }


    #[test]
    fn test_verify() {
        for _ in 0..20 {
            let key = HexString::get_random();

            let scramble = generate_scramble(key.to_cube_index()).unwrap();
            verify(key, scramble);
        }
    }
}