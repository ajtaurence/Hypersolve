use clap::{Parser, Subcommand, ValueEnum};
use hypersolve::{piece_cube::{Twist, puzzle::PieceCube, TwistSequence}, solve::{fast_solve, find_scramble}, hex_string::HexString, cubie_cube::{CubieCube}};
use colored::Colorize;

#[derive(Parser)]
#[command(
    author, 
    version,
    about, 
    long_about = None,
    help_template = "{about-section}{author}\n\n{usage-heading} {usage} \n\n{all-args} {tab}"
)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Solves a scramble
    Solve {
        /// Scramble moves
        moves: Vec<Twist>,

        /// Solution mode
        #[arg(short, long, value_enum, default_value_t = SolveMode::Fast)]
        mode: SolveMode,
    },
    /// Finds upper and lower bounds on the length of the optimal solution
    Bound {
        /// Scramble moves
        moves: Vec<Twist>
    },
    /// Generates a true random state scramble
    Scramble {
        /// A 128 bit hexadecimal verification key
        #[arg(short, long)]
        key: Option<HexString<16>>,
    },
    /// Verifies that a scramble was generated by Hypersolve
    Verify {
        /// A 128 bit hexadecimal verification key
        key: HexString<16>,

        /// Scramble moves
        scramble: Vec<Twist>
    },
    /// Simplifies a move sequence
    Simplify {
        /// Scramble moves
        moves: Vec<Twist>,

        /// Simplification mode
        #[arg(short, long, value_enum)]
        mode: SimplifyMode,
    },
}

#[derive(Clone, Copy, ValueEnum)]
enum SolveMode {
    /// Finds short solutions quickly
    Fast,
    /// Finds the optimal solution
    Optimal,
}

#[derive(Clone, Copy, ValueEnum)]
enum SimplifyMode {
    /// Applies trivial simplifications such as combining moves where possible and removing cube rotations
    Trivial,
    /// Searches for any equivalent but shorter move sequences
    NonTrivial,
}

fn main() {
    // make windows colorize text correctly
    #[cfg(windows)]
    colored::control::set_virtual_terminal(true).unwrap();

    let args = Cli::parse();

    match args.command {
        Commands::Solve { moves, mode } => solve(moves, mode),
        Commands::Scramble { key } => scramble(key),
        Commands::Verify { key, scramble } => verify(key, scramble),
        Commands::Simplify { moves, mode } => simplify(moves, mode),
        Commands::Bound { moves } => bound(moves),
    }
}

/// Function called on solve command
fn solve(moves: Vec<Twist>, mode: SolveMode) {
    match mode {
        SolveMode::Fast => {
            let solutions = fast_solve(PieceCube::solved().twists(moves), None);
            while let Ok((solution, length)) = solutions.recv() {
                println!("[{}]", format!("{} STM", length).yellow().underline());
                println!("{}", solution);
            }            
        },
        SolveMode::Optimal => todo!()
    }
}

/// Function called on scramble command
fn scramble(key: Option<HexString<16>>) {
    let key = key.unwrap_or(HexString::get_random());

    let cube_index = key.to_cube_index();

    let cube = CubieCube::from_index(cube_index).unwrap();

    println!("Verification key: [{}]", key.to_string().yellow().underline());
    println!("{}", find_scramble(cube))
}

/// Function called on verify command
fn verify(key: HexString<16>, scramble: Vec<Twist>) {
    let cube = CubieCube::from_index(key.to_cube_index()).unwrap();

    let expected_scramble = find_scramble(cube);

    if expected_scramble.to_string() == TwistSequence(scramble).to_string() {
        println!("{}", "Valid".green())
    } else {
        println!("{}", "Invalid".red());
    }
}

/// Function called on simplify command
fn simplify(_moves: Vec<Twist>, _mode: SimplifyMode) {
    todo!()
}

/// Function called on bound command
fn bound(_moves: Vec<Twist>) {
    todo!()
}